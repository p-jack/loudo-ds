import { test, expect, describe, beforeEach } from "vitest"
import { Ring } from "./index"
import { LEvent, Stash, Sized } from "loudo-ds-core"
import { AChange, BaseA } from "loudo-ds-array-interfaces"
import { mixin, mixed } from "loudo-mixin"

interface Capture<T extends {}> {
  captured():LEvent<T,number>|undefined
  added():T[]
  removed():T[]
  ear(event:LEvent<T,number>):void
}

function capture<T extends {}>():Capture<T> {
  let captured:LEvent<T,number>|undefined = undefined
  return {
    captured:() => { const r = captured; captured = undefined; return r },
    added:() => captured?.added ? [...captured.added.elements] : [],
    removed:() => captured?.removed ? [...captured.removed.elements] : [],
    ear(event:LEvent<T,number>) {
      captured = event
    }
  }
}


type C = new()=>Ring<string>

describe("Ring", () => {
  let full = new Ring<string>([], 5)
  let fullC = capture<string>()
  let partial = new Ring<string>([], 5)
  let partialC = capture<string>()
  beforeEach(() => {
    full = new Ring(["A", "B", "C", "D", "E"], 5)
    fullC = capture<string>()
    full.hear(fullC.ear)
    fullC.captured()
    partial = new Ring(["A", "B"], 5)
    partialC = capture<string>()
    partial.hear(partialC.ear)
    partialC.captured()
  })
  test("constructor", () => {
    expect(() => { new Ring(["1", "2"], 0.5) }).toThrowError()
    expect(() => { new Ring(["1", "2"], 0) }).toThrowError()
    expect(() => { new Ring(["1", "2"], -100) }).toThrowError()
  })
  test("mixins", () => {
    expect(mixed(full, AChange)).toBe(true)
    expect(mixed(full, BaseA)).toBe(true)
    expect(mixed(full, Stash)).toBe(true)
    expect(mixed(full, Sized)).toBe(true)
  })
  test("at", () => {
    expect(full.at(0)).toBe("A")
    expect(full.at(1)).toBe("B")
    expect(full.at(2)).toBe("C")
    expect(full.at(3)).toBe("D")
    expect(full.at(4)).toBe("E")
  })
  test("eq", () => {
    expect(full.eq === Object.is).toBe(true)
    expect(partial.eq === Object.is).toBe(true)
  })
  test("full", () => {
    expect(full.full).toBe(true)
    expect(partial.full).toBe(false)
  })
  test("iterator", () => {
    expect([...full]).toStrictEqual(["A", "B", "C", "D", "E"])
  })
  describe("push", () => {
    test("partial", () => {
      partial.push("C")
      expect([...partial]).toStrictEqual(["A", "B", "C"])
      expect(partialC.added()).toStrictEqual(["C"])
      const evt = partialC.captured()
      expect(evt?.cleared).toBe(false)
      expect(evt?.removed).toBeUndefined()
      expect(evt?.added?.at).toBe(2)
    })
    test("full", () => {
      full.push("F")
      expect([...full]).toStrictEqual(["B", "C", "D", "E", "F"])
      expect(fullC.removed()).toStrictEqual(["A"])
      expect(fullC.added()).toStrictEqual(["F"])
      const evt = fullC.captured()
      expect(evt?.cleared).toBe(false)
      expect(evt?.removed?.at).toBe(0)
      expect(evt?.added?.at).toBe(4)  
    })
  })
  describe("pushAll", () => {
    describe("BaseA", () => {
      test("partial replacement", () => {
        full.pushAll(TestA.of("f", "g"))
        expect([...full]).toStrictEqual(["C", "D", "E", "f", "g"])
        expect(fullC.removed()).toStrictEqual(["A", "B"])
        expect(fullC.added()).toStrictEqual(["f", "g"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed?.at).toBe(0)
        expect(evt?.added?.at).toBe(3)
        expect(full.at(0)).toBe("C")
        expect(full.at(1)).toBe("D")
        expect(full.at(2)).toBe("E")
        expect(full.at(3)).toBe("f")
        expect(full.at(4)).toBe("g")
      })
      test("full replacement", () => {
        full.pushAll(TestA.of("0", "1", "2", "3", "4"))
        expect([...full]).toStrictEqual(["0", "1", "2", "3", "4"])
        expect(fullC.added()).toStrictEqual(["0", "1", "2", "3", "4"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
      })
      test("overage", () => {
        full.pushAll(TestA.of("0", "1", "2", "3", "4", "5"))
        expect([...full]).toStrictEqual(["1", "2", "3", "4", "5"])
        expect(fullC.added()).toStrictEqual(["1", "2", "3", "4", "5"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
      })
    })
    describe("array", () => {
      test("partial replacement", () => {
        full.pushAll(["f", "g"])
        expect([...full]).toStrictEqual(["C", "D", "E", "f", "g"])
        expect(fullC.removed()).toStrictEqual(["A", "B"])
        expect(fullC.added()).toStrictEqual(["f", "g"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed?.at).toBe(0)
        expect(evt?.added?.at).toBe(3)
        expect(full.at(0)).toBe("C")
        expect(full.at(1)).toBe("D")
        expect(full.at(2)).toBe("E")
        expect(full.at(3)).toBe("f")
        expect(full.at(4)).toBe("g")
      })
      test("full replacement", () => {
        full.pushAll(["0", "1", "2", "3", "4"])
        expect([...full]).toStrictEqual(["0", "1", "2", "3", "4"])
        expect(fullC.added()).toStrictEqual(["0", "1", "2", "3", "4"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
      })
      test("overage", () => {
        full.pushAll(["0", "1", "2", "3", "4", "5"])
        expect([...full]).toStrictEqual(["1", "2", "3", "4", "5"])
        expect(fullC.added()).toStrictEqual(["1", "2", "3", "4", "5"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
      })
    })
    describe("non-array", () => {
      test("partial replacement", () => {
        full.pushAll(new Set(["f", "g"]))
        expect([...full]).toStrictEqual(["C", "D", "E", "f", "g"])
        expect(fullC.removed()).toStrictEqual(["A", "B"])
        expect(fullC.added()).toStrictEqual(["f", "g"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed?.at).toBe(0)
        expect(evt?.added?.at).toBe(3)
        expect(full.at(0)).toBe("C")
        expect(full.at(1)).toBe("D")
        expect(full.at(2)).toBe("E")
        expect(full.at(3)).toBe("f")
        expect(full.at(4)).toBe("g")
      })
      test("full replacement", () => {
        full.pushAll(new Set(["0", "1", "2", "3", "4"]))
        expect([...full]).toStrictEqual(["0", "1", "2", "3", "4"])
        expect(fullC.added()).toStrictEqual(["0", "1", "2", "3", "4"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
      })
      test("overage", () => {
        full.pushAll(new Set(["0", "1", "2", "3", "4", "5"]))
        expect([...full]).toStrictEqual(["1", "2", "3", "4", "5"])
        expect(fullC.added()).toStrictEqual(["1", "2", "3", "4", "5"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
      })
    })
  })
  test("size", () => {
    expect(full.size).toBe(5)
    expect(partial.size).toBe(2)
  })
  test("set", () => {
    full.push("F")
    fullC.captured()
    full.set(2, "d")
    expect(fullC.removed()).toStrictEqual(["D"])
    expect(fullC.added()).toStrictEqual(["d"])
    const evt = fullC.captured()
    expect(evt?.cleared).toBe(false)
    expect(evt?.removed?.at).toBe(2)
    expect(evt?.removed?.at).toBe(2)
    full.set(2, "d")
    expect(fullC.captured()).toBeUndefined()
  })
  describe("unshift", () => {
    test("not full", () => {
      partial.unshift("z")
      expect([...partial]).toStrictEqual(["z", "A", "B"])
      expect(partialC.added()).toStrictEqual(["z"])
      const evt = partialC.captured()
      expect(evt?.cleared).toBe(false)
      expect(evt?.removed).toBeUndefined()
      expect(evt?.added?.at).toBe(0)  
    })
    test("full", () => {
      full.unshift("z")
      expect([...full]).toStrictEqual(["z", "A", "B", "C", "D"])
      expect(fullC.removed()).toStrictEqual(["E"])
      expect(fullC.added()).toStrictEqual(["z"])
      const evt = fullC.captured()
      expect(evt?.cleared).toBe(false)
      expect(evt?.removed?.at).toBe(4)
      expect(evt?.added?.at).toBe(0)  
    })
  })
  describe("unshiftAll", () => {
    describe("BaseA", () => {
      test("empty", () => {
        full.unshiftAll(TestA.of())
        expect([...full]).toStrictEqual(["A", "B", "C", "D", "E"])
        expect(fullC.captured()).toBeUndefined()
      })
      test("partial replacement", () => {
        full.unshiftAll(TestA.of("0", "1"))
        expect([...full]).toStrictEqual(["0", "1", "A", "B", "C"])
        expect(fullC.removed()).toStrictEqual(["D", "E"])
        expect(fullC.added()).toStrictEqual(["0", "1"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed?.at).toBe(3)
        expect(evt?.removed?.elements?.eq === Object.is).toBe(true)
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("0")
        expect(full.at(1)).toBe("1")
        expect(full.at(2)).toBe("A")
        expect(full.at(3)).toBe("B")
        expect(full.at(4)).toBe("C")
      })
      test("full replacement", () => {
        full.unshiftAll(TestA.of("0", "1", "2", "3", "4"))
        expect([...full]).toStrictEqual(["0", "1", "2", "3", "4"])
        expect(fullC.added()).toStrictEqual(["0", "1", "2", "3", "4"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("0")
        expect(full.at(1)).toBe("1")
        expect(full.at(2)).toBe("2")
        expect(full.at(3)).toBe("3")
        expect(full.at(4)).toBe("4")
      })
      test("overage", () => {
        full.unshiftAll(TestA.of("0", "1", "2", "3", "4", "5"))
        expect([...full]).toStrictEqual(["1", "2", "3", "4", "5"])
        expect(fullC.added()).toStrictEqual(["1", "2", "3", "4", "5"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("1")
        expect(full.at(1)).toBe("2")
        expect(full.at(2)).toBe("3")
        expect(full.at(3)).toBe("4")
        expect(full.at(4)).toBe("5")
      })
      test("small", () => {
        partial.unshiftAll(TestA.of("0", "1"))
        expect([...partial]).toStrictEqual(["0", "1", "A", "B"])
        expect(partialC.added()).toStrictEqual(["0", "1"])
        const evt = partialC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(partial.at(0)).toBe("0")
        expect(partial.at(1)).toBe("1")
        expect(partial.at(2)).toBe("A")
        expect(partial.at(3)).toBe("B")
      })
    })
    describe("array", () => {
      test("partial replacement", () => {
        full.unshiftAll(["0", "1"])
        expect([...full]).toStrictEqual(["0", "1", "A", "B", "C"])
        expect(fullC.removed()).toStrictEqual(["D", "E"])
        expect(fullC.added()).toStrictEqual(["0", "1"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed?.at).toBe(3)
        expect(evt?.removed?.elements?.eq === Object.is).toBe(true)
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("0")
        expect(full.at(1)).toBe("1")
        expect(full.at(2)).toBe("A")
        expect(full.at(3)).toBe("B")
        expect(full.at(4)).toBe("C")
      })
      test("full replacement", () => {
        full.unshiftAll(["0", "1", "2", "3", "4"])
        expect([...full]).toStrictEqual(["0", "1", "2", "3", "4"])
        expect(fullC.added()).toStrictEqual(["0", "1", "2", "3", "4"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("0")
        expect(full.at(1)).toBe("1")
        expect(full.at(2)).toBe("2")
        expect(full.at(3)).toBe("3")
        expect(full.at(4)).toBe("4")
      })
      test("overage", () => {
        full.unshiftAll(["0", "1", "2", "3", "4", "5"])
        expect([...full]).toStrictEqual(["1", "2", "3", "4", "5"])
        expect(fullC.added()).toStrictEqual(["1", "2", "3", "4", "5"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("1")
        expect(full.at(1)).toBe("2")
        expect(full.at(2)).toBe("3")
        expect(full.at(3)).toBe("4")
        expect(full.at(4)).toBe("5")
      })
      test("small", () => {
        partial.unshiftAll(["0", "1"])
        expect([...partial]).toStrictEqual(["0", "1", "A", "B"])
        expect(partialC.added()).toStrictEqual(["0", "1"])
        const evt = partialC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(partial.at(0)).toBe("0")
        expect(partial.at(1)).toBe("1")
        expect(partial.at(2)).toBe("A")
        expect(partial.at(3)).toBe("B")
      })
    })
    describe("non-array", () => {
      test("partial replacement", () => {
        full.unshiftAll(new Set(["0", "1"]))
        expect([...full]).toStrictEqual(["0", "1", "A", "B", "C"])
        expect(fullC.removed()).toStrictEqual(["D", "E"])
        expect(fullC.added()).toStrictEqual(["0", "1"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed?.at).toBe(3)
        expect(evt?.removed?.elements?.eq === Object.is).toBe(true)
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("0")
        expect(full.at(1)).toBe("1")
        expect(full.at(2)).toBe("A")
        expect(full.at(3)).toBe("B")
        expect(full.at(4)).toBe("C")
      })
      test("full replacement", () => {
        full.unshiftAll(new Set(["0", "1", "2", "3", "4"]))
        expect([...full]).toStrictEqual(["0", "1", "2", "3", "4"])
        expect(fullC.added()).toStrictEqual(["0", "1", "2", "3", "4"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("0")
        expect(full.at(1)).toBe("1")
        expect(full.at(2)).toBe("2")
        expect(full.at(3)).toBe("3")
        expect(full.at(4)).toBe("4")
      })
      test("overage", () => {
        full.unshiftAll(new Set(["0", "1", "2", "3", "4", "5"]))
        expect([...full]).toStrictEqual(["1", "2", "3", "4", "5"])
        expect(fullC.added()).toStrictEqual(["1", "2", "3", "4", "5"])
        const evt = fullC.captured()
        expect(evt?.cleared).toBe(true)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(full.at(0)).toBe("1")
        expect(full.at(1)).toBe("2")
        expect(full.at(2)).toBe("3")
        expect(full.at(3)).toBe("4")
        expect(full.at(4)).toBe("5")
      })
      test("small", () => {
        partial.unshiftAll(new Set(["0", "1"]))
        expect([...partial]).toStrictEqual(["0", "1", "A", "B"])
        expect(partialC.added()).toStrictEqual(["0", "1"])
        const evt = partialC.captured()
        expect(evt?.cleared).toBe(false)
        expect(evt?.removed).toBeUndefined()
        expect(evt?.added?.at).toBe(0)
        expect(evt?.added?.elements?.eq === Object.is).toBe(true)
        expect(partial.at(0)).toBe("0")
        expect(partial.at(1)).toBe("1")
        expect(partial.at(2)).toBe("A")
        expect(partial.at(3)).toBe("B")
      })
    })
  })
})

class TestA {
  constructor(readonly a:string[]) {}
  get size() { return this.a.length }
  raw(i:number) { return this.a[i] }
  static of(...items:string[]) { return new TestA(items) }
}
interface TestA extends BaseA<string> {}
mixin(TestA, [BaseA])